<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Dashboard de servidores - Desarrollo de interfaces</title><meta name="description" content="DocumentaciÃ³n TÃ©cnica: ServerManager Arquitectura, API y LÃ³gica de Negocio ServerManager es una soluciÃ³n integral para la orquestaciÃ³n y monitoreo de servidores Docker. Esta documentaciÃ³n detalla la implementaciÃ³n tÃ©cnica de sus servicios backend, la API REST y los componentes frontend, incluyendo ejemplos de cÃ³digo de las&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/dashboard-de-servidores.html"><link rel="alternate" type="application/atom+xml" href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/feed.xml" title="Desarrollo de interfaces - RSS"><link rel="alternate" type="application/json" href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/feed.json" title="Desarrollo de interfaces - JSON"><meta property="og:title" content="Dashboard de servidores"><meta property="og:site_name" content="Desarrollo de interfaces"><meta property="og:description" content="DocumentaciÃ³n TÃ©cnica: ServerManager Arquitectura, API y LÃ³gica de Negocio ServerManager es una soluciÃ³n integral para la orquestaciÃ³n y monitoreo de servidores Docker. Esta documentaciÃ³n detalla la implementaciÃ³n tÃ©cnica de sus servicios backend, la API REST y los componentes frontend, incluyendo ejemplos de cÃ³digo de las&hellip;"><meta property="og:url" content="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/dashboard-de-servidores.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/assets/css/style.css?v=11bee19e86e8eda2cf9a60efd975666d"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/dashboard-de-servidores.html"},"headline":"Dashboard de servidores","datePublished":"2026-01-21T16:19+01:00","dateModified":"2026-01-21T16:23+01:00","description":"DocumentaciÃ³n TÃ©cnica: ServerManager Arquitectura, API y LÃ³gica de Negocio ServerManager es una soluciÃ³n integral para la orquestaciÃ³n y monitoreo de servidores Docker. Esta documentaciÃ³n detalla la implementaciÃ³n tÃ©cnica de sus servicios backend, la API REST y los componentes frontend, incluyendo ejemplos de cÃ³digo de las&hellip;","author":{"@type":"Person","name":"RubÃ©n GarcÃ­a","url":"https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/authors/ruben-garcia/"},"publisher":{"@type":"Organization","name":"RubÃ©n GarcÃ­a"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/">Desarrollo de interfaces</a></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Dashboard de servidores</h1><div class="feed__meta content__meta"><a href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/authors/ruben-garcia/" class="feed__author">RubÃ©n GarcÃ­a</a> <time datetime="2026-01-21T16:19" class="feed__date">January 21, 2026</time></div></div></header></div><div class="entry-wrapper content__entry"><header class="post-header align-center"><h1>DocumentaciÃ³n TÃ©cnica: ServerManager</h1><div class="post-meta"><p>Arquitectura, API y LÃ³gica de Negocio</p></div></header><div class="post-content"><p class="align-center"><img src="https://img.shields.io/badge/Docker-2496ED?style=for-the-badge&amp;logo=docker&amp;logoColor=white" alt="Docker Badge" data-is-external-image="true"> <img loading="lazy" src="https://img.shields.io/badge/Node.js-339933?style=for-the-badge&amp;logo=nodedotjs&amp;logoColor=white" alt="Node.js Badge" data-is-external-image="true"> <img loading="lazy" src="https://img.shields.io/badge/React-61DAFB?style=for-the-badge&amp;logo=react&amp;logoColor=black" alt="React Badge" data-is-external-image="true"></p><p class="lead"><strong>ServerManager</strong> es una soluciÃ³n integral para la orquestaciÃ³n y monitoreo de servidores Docker. Esta documentaciÃ³n detalla la implementaciÃ³n tÃ©cnica de sus servicios backend, la API REST y los componentes frontend, incluyendo ejemplos de cÃ³digo de las funcionalidades crÃ­ticas.</p><hr><nav class="toc-container"><h3>Indice de Contenidos</h3><ul><li><a href="#arquitectura">Arquitectura del Sistema</a></li><li><a href="#backend-docker">Servicio: Docker Control</a></li><li><a href="#backend-ssh">Servicio: Cliente SSH</a></li><li><a href="#backend-ftp">Servicio: Gestor FTP</a></li><li><a href="#telegram-bot">LÃ³gica del Bot de Telegram</a></li><li><a href="#frontend-logic">Componentes Frontend</a></li><li><a href="#api-endpoints">API Reference</a></li></ul></nav><hr><section id="arquitectura"><h2>ğŸ—ï¸ Arquitectura del Sistema</h2><p>El proyecto sigue una arquitectura de microservicios donde un servidor central (Node.js/Express) actÃºa como orquestador entre los clientes (Web/Telegram) y los contenedores objetivo.</p><p>El flujo de datos se estructura de la siguiente manera:</p><pre><code class="language-plaintext">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              CLIENTE                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Dashboard Web     â”‚              Bot Telegram                             â”‚
â”‚   (React + Vite)    â”‚         (node-telegram-bot-api)                       â”‚
â”‚   Puerto: 80        â”‚                                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                                      â”‚
          â–¼                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         SERVIDOR API (Node.js/Express)                      â”‚
â”‚                              Puerto: 3000                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Docker       â”‚  â”‚ SSH Client   â”‚  â”‚ FTP Service  â”‚  â”‚ Web Service  â”‚    â”‚
â”‚  â”‚ Control      â”‚  â”‚              â”‚  â”‚              â”‚  â”‚              â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        CONTENEDORES TARGET                                  â”‚
â”‚   SSH (2222)   |   FTP (2121)   |   Web (8080)                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre></section><hr><section id="backend-docker"><h2>ğŸ³ Servicio: Docker Control</h2><p>Ubicado en <code>server/services/dockerControl.js</code>, este servicio utiliza la librerÃ­a <code>dockerode</code> conectada al socket local (<code>/var/run/docker.sock</code>) para manipular contenedores.</p><h3>Filtrado de Contenedores</h3><p>El sistema no muestra todos los contenedores de la mÃ¡quina host, sino que filtra especÃ­ficamente aquellos etiquetados como "target", excluyendo la infraestructura del propio dashboard.</p><pre><code class="language-javascript">const listContainers = async () =&gt; {
    const containers = await docker.listContainers({ all: true });
    // Filtra solo contenedores target (excluye dashboard-server y dashboard-client)
    return containers.filter(c =&gt; c.Names.some(n =&gt;
        n.includes('target') &amp;&amp; !n.includes('dashboard')
    ));
};</code></pre><h3>GestiÃ³n de Recursos en Tiempo Real</h3><p>Una de las funcionalidades mÃ¡s avanzadas es la capacidad de actualizar "en caliente" los lÃ­mites de CPU y Memoria RAM. Para la CPU, se realiza una conversiÃ³n a <code>NanoCpus</code> (1 CPU = 1e9 nanocpus).</p><pre><code class="language-javascript">const updateContainerResources = async (name, resources) =&gt; {
    const container = getContainer(name);
    const updateConfig = {};

    // CPU limit usando NanoCpus (1 CPU = 1e9 nanocpus)
    if (resources.cpuLimit !== undefined) {
        updateConfig.NanoCpus = Math.floor(resources.cpuLimit * 1e9);
    }

    // Memory limit (en bytes)
    if (resources.memoryLimit !== undefined) {
        updateConfig.Memory = resources.memoryLimit * 1024 * 1024; // MB a bytes
    }

    await container.update(updateConfig);
    return { success: true, name, updatedResources: resources };
};</code></pre><h3>CreaciÃ³n DinÃ¡mica de Servidores</h3><p>El sistema permite instanciar nuevos servidores basados en imÃ¡genes pre-configuradas. Se configuran automÃ¡ticamente los mapeos de puertos y polÃ­ticas de red.</p><pre><code class="language-javascript">const createContainer = async (options) =&gt; {
    const { name, type, cpuLimit, memoryLimit } = options;

    const imageMap = {
        ssh: 'servermanager-ssh-target',
        ftp: 'servermanager-ftp-target',
        web: 'servermanager-web-target'
    };

    // ... validaciÃ³n de imagen ...

    const containerConfig = {
        Image: image,
        name: `${name}-${type}-target`,
        HostConfig: {
            RestartPolicy: { Name: 'unless-stopped' },
            NetworkMode: 'servermanager_default',
            // ConfiguraciÃ³n de lÃ­mites y puertos...
        }
    };

    const container = await docker.createContainer(containerConfig);
    await container.start();
    return { success: true, id: container.id };
};</code></pre></section><hr><section id="backend-ssh"><h2>ğŸ’» Servicio: Cliente SSH</h2><p>Implementado en <code>server/services/sshClient.js</code> usando <code>ssh2</code>. Este servicio no solo ejecuta comandos, sino que parsea salidas de comandos Linux para obtener mÃ©tricas.</p><h3>ObtenciÃ³n de MÃ©tricas (Parsing)</h3><p>Para monitorear el estado interno del contenedor sin agentes externos, se ejecutan comandos de shell como <code>grep</code>, <code>awk</code> y <code>free</code> y se procesa su salida estÃ¡ndar.</p><pre><code class="language-javascript">const getSystemStats = async (host, port, username, password) =&gt; {
    // Comando para obtener uso de CPU
    const cpucmd = "grep 'cpu ' /proc/stat | awk '{usage=($2+$4)*100/($2+$4+$5)} END {print usage}'";
    
    // Comando para obtener uso de memoria
    const memcmd = "free -m | awk 'NR==2{printf \"%.2f\", $3*100/$2 }'";
    
    // EjecuciÃ³n paralela
    const [cpu, mem, disk] = await Promise.all([
        executeCommand(host, port, username, password, cpucmd),
        executeCommand(host, port, username, password, memcmd),
        // ...
    ]);

    return {
        cpu: parseFloat(cpu) || 0,
        memory: parseFloat(mem) || 0,
        // ...
    };
};</code></pre></section><hr><section id="backend-ftp"><h2>ğŸ“‚ Servicio: Gestor FTP</h2><p>El archivo <code>server/services/ftpService.js</code> utiliza <code>basic-ftp</code>. Permite operaciones complejas como la descarga de archivos binarios a rutas temporales para su posterior procesamiento.</p><pre><code class="language-javascript">// Descarga segura a ruta temporal
const downloadToPath = async (host, port, user, password, remotePath) =&gt; {
    const client = await connect(host, port, user, password);
    const ext = path.extname(remotePath) || '.bin';
    const localPath = `/tmp/ftp_download_${Date.now()}${ext}`;
    
    try {
        await client.downloadTo(localPath, remotePath);
        return localPath;
    } finally {
        client.close();
    }
};</code></pre></section><hr><section id="telegram-bot"><h2>ğŸ¤– LÃ³gica del Bot de Telegram</h2><p>El servicio <code>server/services/telegramBot.js</code> implementa un sistema de logs en memoria y una interfaz visual basada en texto para Telegram.</p><h3>VisualizaciÃ³n de EstadÃ­sticas (ASCII Art)</h3><p>Genera barras de progreso visuales utilizando caracteres Unicode para representar el uso de CPU y RAM directamente en el chat.</p><pre><code class="language-javascript">const createProgressBar = (percentage) =&gt; {
    const total = 10;
    const filled = Math.round((percentage / 100) * total);
    // Genera barra tipo: ğŸ”´ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘
    return 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(total - filled);
};

const formatStats = (stats, serverNumber, serverName) =&gt; {
    // LÃ³gica para indicadores de color segÃºn severidad
    const getIndicator = (value) =&gt; {
        if (value &gt;= 90) return 'ğŸ”´';
        if (value &gt;= 70) return 'ğŸŸ ';
        return 'ğŸŸ¢';
    };
    // Retorna string formateado en Markdown
};</code></pre><h3>EjecuciÃ³n de Comandos SSH desde Chat</h3><p>El bot intercepta comandos con regex (<code>/\/ssh (\d+)\s+(.+)/</code>), valida el tipo de servidor y ejecuta el comando remoto, devolviendo la salida en un bloque de cÃ³digo.</p><pre><code class="language-javascript">bot.onText(/\/ssh (\d+)\s+(.+)/, async (msg, match) =&gt; {
    const serverNum = parseInt(match[1]);
    const command = match[2].trim();

    // ... validaciÃ³n de servidor ...

    const output = await sshService.executeCommand(
        server.name, 22, 'root', 'password', command
    );

    const response = `
ğŸ’» *Resultado SSH - #${serverNum}*
ğŸ“ *Comando:* \`${command}\`
ğŸ“¤ *Salida:*
\`\`\`
${output.substring(0, 3000)}
\`\`\`
    `;
    bot.sendMessage(chatId, response, { parse_mode: 'Markdown' });
});</code></pre></section><hr><section id="frontend-logic"><h2>ğŸ¨ Componentes Frontend (React)</h2><h3>Terminal Web (Xterm.js + Socket.IO)</h3><p>El componente <code>Terminal.jsx</code> crea un puente bidireccional. Captura la entrada del usuario en el navegador, la envÃ­a por WebSocket al backend, y escribe la respuesta del shell SSH en el canvas de xterm.</p><pre><code class="language-javascript">useEffect(() =&gt; {
    const term = new Terminal({ cursorBlink: true });
    // ... configuraciÃ³n de tema ...
    
    const socket = io();

    socket.on('connect', () =&gt; {
        socket.emit('start-terminal', {
            host: serverName,
            port: 22,
            // credenciales...
        });
    });

    // Escribir datos recibidos del servidor en la terminal
    socket.on('data', (data) =&gt; {
        term.write(data);
    });

    // Enviar input del usuario al servidor
    term.onData(data =&gt; {
        socket.emit('input', data);
    });

    return () =&gt; { socket.disconnect(); term.dispose(); };
}, [serverName]);</code></pre><h3>Panel de Control del Bot</h3><p>El dashboard permite a los administradores ver quÃ© estÃ¡ sucediendo en el bot de Telegram en tiempo real mediante un polling al endpoint de logs.</p><pre><code class="language-javascript">const TelegramBotPanel = () =&gt; {
    const [logs, setLogs] = useState([]);

    // Auto-refresh cada 5 segundos para simular tiempo real
    useEffect(() =&gt; {
        const interval = setInterval(() =&gt; {
            fetchLogs();
            fetchStatus();
        }, 5000);
        return () =&gt; clearInterval(interval);
    }, []);

    // ... renderizado de tabla de logs ...
}</code></pre></section><hr><section id="api-endpoints"><h2>ğŸŒ Referencia de API REST</h2><p>La comunicaciÃ³n entre el frontend y los microservicios se realiza a travÃ©s de una API RESTful documentada a continuaciÃ³n.</p><h3>Servidores (Docker)</h3><div class="table-wrapper"><table><thead><tr><th>MÃ©todo</th><th>Endpoint</th><th>Payload</th><th>DescripciÃ³n</th></tr></thead><tbody><tr><td><code>POST</code></td><td><code>/api/servers/docker/create</code></td><td><code>{ name, type, cpuLimit }</code></td><td>Crea un nuevo contenedor basado en plantillas.</td></tr><tr><td><code>PUT</code></td><td><code>/api/servers/:name/resources</code></td><td><code>{ cpuLimit, memoryLimit }</code></td><td>Actualiza lÃ­mites de recursos en caliente.</td></tr><tr><td><code>GET</code></td><td><code>/api/servers/:name/inspect</code></td><td>-</td><td>Devuelve JSON crudo de <code>docker inspect</code>.</td></tr></tbody></table></div><h3>Archivos (FTP)</h3><div class="table-wrapper"><table><thead><tr><th>MÃ©todo</th><th>Endpoint</th><th>Payload</th><th>DescripciÃ³n</th></tr></thead><tbody><tr><td><code>POST</code></td><td><code>/api/ftp/list</code></td><td><code>{ host, path }</code></td><td>Lista archivos y directorios del path remoto.</td></tr><tr><td><code>POST</code></td><td><code>/api/ftp/save</code></td><td><code>{ path, content }</code></td><td>Guarda contenido de texto en el archivo remoto.</td></tr></tbody></table></div></section></div></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on January 21, 2026</p><div class="content__actions"><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"></div></div></div><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/authors/ruben-garcia/" rel="author">RubÃ©n GarcÃ­a</a></h3></div></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/novelavisual.html" class="content__nav-link" rel="prev"><div><span>Previous</span> NovelaVisual</div></a></div></div></div></nav></footer></article></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright">Powered by Publii</div><button id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>