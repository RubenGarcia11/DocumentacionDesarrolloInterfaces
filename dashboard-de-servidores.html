<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Dashboard de servidores - Desarrollo de interfaces</title><meta name="description" content="ServerManager: DocumentaciÃ³n TÃ©cnica Oficial OrquestaciÃ³n de Contenedores, TÃºneles Ngrok y AutomatizaciÃ³n vÃ­a Telegram ServerManager es una plataforma integral diseÃ±ada para la gestiÃ³n de infraestructura contenerizada. Permite administrar servidores SSH, FTP y Web a travÃ©s de un Dashboard moderno en React y un Bot de Telegram&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/dashboard-de-servidores.html"><link rel="alternate" type="application/atom+xml" href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/feed.xml" title="Desarrollo de interfaces - RSS"><link rel="alternate" type="application/json" href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/feed.json" title="Desarrollo de interfaces - JSON"><meta property="og:title" content="Dashboard de servidores"><meta property="og:site_name" content="Desarrollo de interfaces"><meta property="og:description" content="ServerManager: DocumentaciÃ³n TÃ©cnica Oficial OrquestaciÃ³n de Contenedores, TÃºneles Ngrok y AutomatizaciÃ³n vÃ­a Telegram ServerManager es una plataforma integral diseÃ±ada para la gestiÃ³n de infraestructura contenerizada. Permite administrar servidores SSH, FTP y Web a travÃ©s de un Dashboard moderno en React y un Bot de Telegram&hellip;"><meta property="og:url" content="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/dashboard-de-servidores.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/assets/css/style.css?v=11bee19e86e8eda2cf9a60efd975666d"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/dashboard-de-servidores.html"},"headline":"Dashboard de servidores","datePublished":"2026-01-21T16:19+01:00","dateModified":"2026-01-21T16:33+01:00","description":"ServerManager: DocumentaciÃ³n TÃ©cnica Oficial OrquestaciÃ³n de Contenedores, TÃºneles Ngrok y AutomatizaciÃ³n vÃ­a Telegram ServerManager es una plataforma integral diseÃ±ada para la gestiÃ³n de infraestructura contenerizada. Permite administrar servidores SSH, FTP y Web a travÃ©s de un Dashboard moderno en React y un Bot de Telegram&hellip;","author":{"@type":"Person","name":"RubÃ©n GarcÃ­a","url":"https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/authors/ruben-garcia/"},"publisher":{"@type":"Organization","name":"RubÃ©n GarcÃ­a"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/">Desarrollo de interfaces</a></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Dashboard de servidores</h1><div class="feed__meta content__meta"><a href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/authors/ruben-garcia/" class="feed__author">RubÃ©n GarcÃ­a</a> <time datetime="2026-01-21T16:19" class="feed__date">January 21, 2026</time></div></div></header></div><div class="entry-wrapper content__entry"><header class="post-header align-center"><h1>ServerManager: DocumentaciÃ³n TÃ©cnica Oficial</h1><div class="post-meta"><p>OrquestaciÃ³n de Contenedores, TÃºneles Ngrok y AutomatizaciÃ³n vÃ­a Telegram</p></div></header><div class="post-content"><p class="align-center"><img src="https://img.shields.io/badge/Telegram-2CA5E0?style=for-the-badge&amp;logo=telegram&amp;logoColor=white" alt="Telegram Logo" data-is-external-image="true"> <img loading="lazy" src="https://img.shields.io/badge/Docker-2496ED?style=for-the-badge&amp;logo=docker&amp;logoColor=white" alt="Docker Badge" data-is-external-image="true"> <img src="https://img.shields.io/badge/Node.js-339933?style=for-the-badge&amp;logo=nodedotjs&amp;logoColor=white" alt="Node.js Badge" data-is-external-image="true"> <img loading="lazy" src="https://img.shields.io/badge/React-61DAFB?style=for-the-badge&amp;logo=react&amp;logoColor=black" alt="React Badge" data-is-external-image="true"> <img loading="lazy" src="https://img.shields.io/badge/Ngrok-1F1E38?style=for-the-badge&amp;logo=ngrok&amp;logoColor=white" alt="Ngrok Badge" data-is-external-image="true"></p><p class="lead"><strong>ServerManager</strong> es una plataforma integral diseÃ±ada para la gestiÃ³n de infraestructura contenerizada. Permite administrar servidores SSH, FTP y Web a travÃ©s de un Dashboard moderno en React y un Bot de Telegram interactivo, integrando servicios de exposiciÃ³n pÃºblica segura mediante Ngrok.</p><hr><nav class="toc-container" style="background: #f8f9fa; padding: 20px; border-radius: 8px; border: 1px solid #e9ecef;"><h3 style="margin-top: 0;">ğŸ“š Ãndice de Contenidos</h3><ul style="column-count: 2; margin-bottom: 0;"><li><a href="#arquitectura">Arquitectura del Sistema</a></li><li><a href="#docker-core">Core: Control de Docker</a></li><li><a href="#ssh-monitoring">MonitorizaciÃ³n SSH (Agentless)</a></li><li><a href="#ftp-manager">Gestor de Archivos FTP</a></li><li><a href="#ngrok-service">Conectividad: Ngrok</a></li><li><a href="#telegram-bot">AutomatizaciÃ³n: Bot Telegram</a></li><li><a href="#frontend">Frontend &amp; WebSockets</a></li><li><a href="#api">Referencia API REST</a></li></ul></nav><hr><section id="arquitectura"><h2>ğŸ—ï¸ Arquitectura de Microservicios</h2><p>El sistema opera bajo un modelo de arquitectura hexagonal donde el servidor API central gestiona la comunicaciÃ³n entre los clientes (Web/MÃ³vil) y los contenedores objetivo. La comunicaciÃ³n es asÃ­ncrona y basada en eventos para tareas de larga duraciÃ³n como terminales remotas.</p><p>El flujo de datos se distribuye de la siguiente manera:</p><pre><code class="language-plaintext">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              CLIENTE                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Dashboard Web     â”‚              Bot Telegram                             â”‚
â”‚   (React + Vite)    â”‚         (node-telegram-bot-api)                       â”‚
â”‚   Puerto: 80        â”‚                                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                                      â”‚
          â–¼                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         SERVIDOR API (Node.js/Express)                      â”‚
â”‚                              Puerto: 3000                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Docker       â”‚  â”‚ SSH Client   â”‚  â”‚ FTP Service  â”‚  â”‚ Ngrok        â”‚    â”‚
â”‚  â”‚ Control      â”‚  â”‚              â”‚  â”‚              â”‚  â”‚ Service      â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        CONTENEDORES TARGET                                  â”‚
â”‚   SSH (2222)   |   FTP (2121)   |   Web (8080)                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre></section><hr><section id="docker-core"><h2>ğŸ³ Core: Control de Docker</h2><p>El servicio <code>server/services/dockerControl.js</code> actÃºa como la capa de abstracciÃ³n principal sobre el daemon de Docker. Utiliza <code>dockerode</code> conectado al socket local <code>/var/run/docker.sock</code> para manipular el ciclo de vida de los contenedores.</p><h3>1. InicializaciÃ³n y ConexiÃ³n</h3><p>La conexiÃ³n se establece directamente al socket Unix, lo que requiere que el contenedor del dashboard tenga montado el volumen <code>/var/run/docker.sock:/var/run/docker.sock</code>.</p><pre><code class="language-javascript">const Docker = require('dockerode');
// ConexiÃ³n directa al socket del host
const docker = new Docker({ socketPath: '/var/run/docker.sock' });

const getContainer = (name) =&gt; docker.getContainer(name);</code></pre><h3>2. Listado Inteligente y Filtrado</h3><p>El sistema distingue entre contenedores de infraestructura (dashboard) y contenedores de usuario (targets). Esto evita que un usuario detenga accidentalmente el propio panel de control.</p><pre><code class="language-javascript">const listContainers = async () =&gt; {
    const containers = await docker.listContainers({ all: true });
    // LÃ³gica de filtrado: Solo mostrar contenedores que:
    // 1. Tengan 'target' en el nombre
    // 2. NO sean parte del dashboard (server/client)
    return containers.filter(c =&gt; c.Names.some(n =&gt;
        n.includes('target') &amp;&amp; !n.includes('dashboard')
    ));
};</code></pre><h3>3. ModificaciÃ³n de Recursos "En Caliente"</h3><p>Una caracterÃ­stica avanzada es la actualizaciÃ³n dinÃ¡mica de lÃ­mites de recursos (Hot Update). Docker requiere unidades especÃ­ficas (NanoCpus para CPU, Bytes para RAM), por lo que el servicio realiza la conversiÃ³n matemÃ¡tica necesaria.</p><pre><code class="language-javascript">const updateContainerResources = async (name, resources) =&gt; {
    const container = getContainer(name);
    const updateConfig = {};

    // ConversiÃ³n CPU: 1 Core = 1,000,000,000 NanoCpus
    if (resources.cpuLimit !== undefined) {
        updateConfig.NanoCpus = Math.floor(resources.cpuLimit * 1e9);
    }

    // ConversiÃ³n Memoria: MB a Bytes
    if (resources.memoryLimit !== undefined) {
        updateConfig.Memory = resources.memoryLimit * 1024 * 1024;
        // Opcional: Establecer reserva de memoria suave
        if (resources.memoryReservation) {
             updateConfig.MemoryReservation = resources.memoryReservation * 1024 * 1024;
        }
    }

    // AplicaciÃ³n inmediata mediante API update sin reiniciar
    await container.update(updateConfig);
    return { success: true, name, updatedResources: resources };
};</code></pre><h3>4. FactorÃ­a de CreaciÃ³n de Servidores</h3><p>Implementa un patrÃ³n Factory para instanciar nuevos servidores basados en plantillas de imÃ¡genes predefinidas. Se configuran automÃ¡ticamente los <code>HostConfig</code> para reinicios automÃ¡ticos y binding de puertos especÃ­ficos segÃºn el tipo (SSH, FTP, Web).</p></section><hr><section id="ssh-monitoring"><h2>ğŸ’» MonitorizaciÃ³n SSH (Agentless)</h2><p>El servicio <code>sshClient.js</code> demuestra una arquitectura "sin agentes". En lugar de instalar software de monitoreo en cada contenedor target, el dashboard se conecta vÃ­a SSH y ejecuta comandos nativos de Linux para extraer mÃ©tricas.</p><h3>Cliente SSH Promisificado</h3><p>Se envuelve la librerÃ­a <code>ssh2</code> en una Promesa para manejar el flujo asÃ­ncrono de manera limpia dentro de las rutas de Express.</p><pre><code class="language-javascript">const executeCommand = (host, port, username, password, command) =&gt; {
    return new Promise((resolve, reject) =&gt; {
        const conn = new Client();
        conn.on('ready', () =&gt; {
            conn.exec(command, (err, stream) =&gt; {
                if (err) return reject(err);
                let output = '';
                stream.on('data', (data) =&gt; { output += data; })
                      .on('close', () =&gt; { conn.end(); resolve(output); });
            });
        }).connect({ host, port, username, password });
    });
};</code></pre><h3>Parsing de MÃ©tricas del Kernel</h3><p>Para obtener el uso de CPU y RAM sin herramientas como <code>htop</code> instaladas, se leen archivos del sistema proc o se usa <code>free</code>/<code>df</code> parseando la salida con <code>awk</code>.</p><pre><code class="language-javascript">const getSystemStats = async (host, port, username, password) =&gt; {
    try {
        // CÃ¡lculo de CPU basado en /proc/stat
        const cpucmd = "grep 'cpu ' /proc/stat | awk '{usage=($2+$4)*100/($2+$4+$5)} END {print usage}'";
        
        // CÃ¡lculo de RAM libre vs total
        const memcmd = "free -m | awk 'NR==2{printf \"%.2f\", $3*100/$2 }'";

        // EjecuciÃ³n paralela para minimizar latencia de red
        const [cpu, mem] = await Promise.all([
            executeCommand(host, port, username, password, cpucmd),
            executeCommand(host, port, username, password, memcmd)
        ]);

        return { cpu: parseFloat(cpu), memory: parseFloat(mem) };
    } catch (err) {
        return { error: err.message };
    }
};</code></pre></section><hr><section id="ftp-manager"><h2>ğŸ“‚ Gestor de Archivos FTP</h2><p>El servicio <code>ftpService.js</code> utiliza <code>basic-ftp</code> para ofrecer una experiencia de explorador de archivos completa. Una de las funciones mÃ¡s complejas es la **ediciÃ³n de archivos remotos**.</p><h3>Flujo de EdiciÃ³n: Descarga -&gt; ModificaciÃ³n -&gt; Subida</h3><p>Como FTP no permite ediciÃ³n "in-place", el sistema descarga el archivo a una ruta temporal en el contenedor del servidor, lee el contenido, permite al frontend editarlo, y lo vuelve a subir.</p><pre><code class="language-javascript">const saveFile = async (host, port, user, password, remotePath, content) =&gt; {
    const client = await connect(host, port, user, password);
    // Crear archivo temporal Ãºnico
    const localPath = `/tmp/ftp_save_${Date.now()}.txt`;
    
    try {
        // 1. Escribir contenido nuevo en local
        fs.writeFileSync(localPath, content, 'utf-8');
        
        // 2. Subir y sobrescribir en remoto
        await client.uploadFrom(localPath, remotePath);
        
        // 3. Limpieza
        fs.unlinkSync(localPath);
    } finally {
        client.close();
    }
};</code></pre></section><hr><section id="ngrok-service"><h2>ğŸŒ Conectividad Externa: Servicio Ngrok</h2><p>El servicio <code>server/services/ngrokService.js</code> gestiona la exposiciÃ³n de servidores locales a internet. Es crucial para compartir el acceso a servidores web de desarrollo con usuarios externos.</p><h3>PatrÃ³n Singleton para TÃºneles</h3><p>El servicio mantiene un cachÃ© en memoria (<code>activeTunnels</code>). Si se solicita un tÃºnel para un puerto que ya estÃ¡ expuesto, devuelve la URL existente en lugar de intentar abrir otro proceso ngrok, lo que fallarÃ­a o consumirÃ­a lÃ­mites.</p><pre><code class="language-javascript">const ngrok = require('@ngrok/ngrok');
let activeTunnels = {};

const startTunnel = async (targetHost, targetPort) =&gt; {
    const key = `${targetHost}:${targetPort}`;

    // 1. VerificaciÃ³n de cachÃ©
    if (activeTunnels[key] &amp;&amp; activeTunnels[key].url) {
        return activeTunnels[key];
    }

    // 2. CreaciÃ³n del tÃºnel seguro
    const listener = await ngrok.forward({
        addr: `${targetHost}:${targetPort}`,
        authtoken: process.env.NGROK_AUTHTOKEN, 
        proto: 'http'
    });

    // 3. Registro en memoria
    activeTunnels[key] = {
        url: listener.url(),
        listener: listener,
        createdAt: Date.now()
    };

    console.log(`ğŸŒ Ngrok tunnel created: ${listener.url()}`);
    return activeTunnels[key];
};</code></pre></section><hr><section id="telegram-bot"><h2>ğŸ¤– AutomatizaciÃ³n: Bot de Telegram</h2><p>El bot (<code>server/services/telegramBot.js</code>) funciona como un panel de administraciÃ³n secundario. Implementa un sistema de logs en memoria para auditorÃ­a y visualizaciÃ³n ASCII.</p><h3>VisualizaciÃ³n ASCII de Recursos</h3><p>Para ofrecer un feedback visual inmediato en una interfaz de texto, el bot renderiza barras de progreso usando caracteres Unicode.</p><pre><code class="language-javascript">const createProgressBar = (percentage) =&gt; {
    const total = 10;
    const filled = Math.round((percentage / 100) * total);
    // Genera: ğŸŸ¢ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘ 60%
    return 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(total - filled);
};</code></pre><h3>SimulaciÃ³n de InteracciÃ³n</h3><p>El bot responde a comandos y muestra la salida de consola formateada en bloques de cÃ³digo Markdown.</p><div class="chat-simulation" style="background: #1e293b; color: #e2e8f0; padding: 15px; border-radius: 8px; font-family: monospace; margin-bottom: 15px; border-left: 5px solid #2CA5E0;"><p style="color: #60a5fa; margin: 0 0 10px 0;"><strong>Usuario:</strong> /ssh 1 ls -la /var/www</p><p style="margin: 0 0 10px 0;"><strong>Bot:</strong> ğŸ”„ Ejecutando: `ls -la /var/www`...</p><div style="background: #0f172a; padding: 10px; border-radius: 4px; margin-top: 5px;"><p style="margin: 0; font-weight: bold; color: #38bdf8;">ğŸ’» Resultado SSH - #1</p><div style="margin-top: 5px; color: #94a3b8; font-size: 0.9em;">drwxr-xr-x 2 root root 4096 Jan 20 10:00 html<br>-rw-r--r-- 1 root root 612 Jan 19 15:30 index.html</div></div></div><h3>Captura de Comandos con Regex</h3><pre><code class="language-javascript">bot.onText(/\/ssh (\d+)\s+(.+)/, async (msg, match) =&gt; {
    const chatId = msg.chat.id;
    const serverNum = parseInt(match[1]); // Captura ID servidor
    const command = match[2].trim();      // Captura comando
    
    // ... ValidaciÃ³n de estado del servidor ...

    const output = await sshService.executeCommand(...);
    
    // Respuesta formateada
    bot.sendMessage(chatId, `\`\`\`\n${output}\n\`\`\``, { 
        parse_mode: 'Markdown' 
    });
});</code></pre></section><hr><section id="frontend"><h2>ğŸ¨ Frontend &amp; WebSockets</h2><h3>Terminal Web en Tiempo Real (Xterm.js)</h3><p>El componente <code>Terminal.jsx</code> crea un puente bidireccional. Captura la entrada del usuario en el navegador, la envÃ­a por WebSocket al backend, y escribe la respuesta del shell SSH en el canvas de xterm.js.</p><pre><code class="language-javascript">// Frontend: InicializaciÃ³n de Terminal y Socket
useEffect(() =&gt; {
    const term = new Terminal({ 
        cursorBlink: true,
        theme: { background: '#020617', foreground: '#f8fafc' }
    });
    
    const socket = io();

    socket.on('connect', () =&gt; {
        term.write(`\r\nConectando...\r\n`);
        // Iniciar sesiÃ³n SSH desde el backend
        socket.emit('start-terminal', {
            host: serverName, port: 22, username: 'admin', password: 'password'
        });
    });

    // RecepciÃ³n: Backend -&gt; Xterm
    socket.on('data', (data) =&gt; term.write(data));

    // EnvÃ­o: Teclado -&gt; Backend
    term.onData(data =&gt; socket.emit('input', data));

    return () =&gt; { socket.disconnect(); term.dispose(); };
}, [serverName]);</code></pre></section><hr><section id="api"><h2>ğŸŒ Referencia API REST</h2><p>Resumen de los endpoints principales expuestos por el backend Express.</p><div class="table-wrapper"><table><thead><tr><th>Contexto</th><th>MÃ©todo</th><th>Endpoint</th><th>DescripciÃ³n Funcional</th></tr></thead><tbody><tr><td><strong>Docker</strong></td><td>POST</td><td><code>/api/servers/:name/start</code></td><td>Inicia un contenedor detenido.</td></tr><tr><td><strong>Docker</strong></td><td>PUT</td><td><code>/api/servers/:name/resources</code></td><td>Actualiza CPU/RAM en caliente.</td></tr><tr><td><strong>Web</strong></td><td>POST</td><td><code>/api/web/deploy</code></td><td>Despliega cÃ³digo HTML al servidor web target.</td></tr><tr><td><strong>Telegram</strong></td><td>GET</td><td><code>/api/telegram/logs</code></td><td>Recupera el historial de chat para auditorÃ­a.</td></tr><tr><td><strong>FTP</strong></td><td>POST</td><td><code>/api/ftp/save</code></td><td>Guarda contenido de texto editado.</td></tr></tbody></table></div></section></div></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on January 21, 2026</p><div class="content__actions"><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"></div></div></div><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/authors/ruben-garcia/" rel="author">RubÃ©n GarcÃ­a</a></h3></div></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/novelavisual.html" class="content__nav-link" rel="prev"><div><span>Previous</span> NovelaVisual</div></a></div></div></div></nav></footer></article></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright">Powered by Publii</div><button id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>