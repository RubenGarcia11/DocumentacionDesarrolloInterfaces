<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Dashboard de servidores - Desarrollo de interfaces</title><meta name="description" content="ServerManager: DocumentaciÃ³n TÃ©cnica Completa OrquestaciÃ³n Docker, TÃºneles Ngrok y AutomatizaciÃ³n vÃ­a Telegram ServerManager es una plataforma integral para la gestiÃ³n de infraestructura contenerizada. Permite administrar servidores SSH, FTP y Web a travÃ©s de un Dashboard moderno y un Bot de Telegram interactivo, integrando servicios de&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/dashboard-de-servidores.html"><link rel="alternate" type="application/atom+xml" href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/feed.xml" title="Desarrollo de interfaces - RSS"><link rel="alternate" type="application/json" href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/feed.json" title="Desarrollo de interfaces - JSON"><meta property="og:title" content="Dashboard de servidores"><meta property="og:site_name" content="Desarrollo de interfaces"><meta property="og:description" content="ServerManager: DocumentaciÃ³n TÃ©cnica Completa OrquestaciÃ³n Docker, TÃºneles Ngrok y AutomatizaciÃ³n vÃ­a Telegram ServerManager es una plataforma integral para la gestiÃ³n de infraestructura contenerizada. Permite administrar servidores SSH, FTP y Web a travÃ©s de un Dashboard moderno y un Bot de Telegram interactivo, integrando servicios de&hellip;"><meta property="og:url" content="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/dashboard-de-servidores.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/assets/css/style.css?v=11bee19e86e8eda2cf9a60efd975666d"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/dashboard-de-servidores.html"},"headline":"Dashboard de servidores","datePublished":"2026-01-21T16:19+01:00","dateModified":"2026-01-21T16:27+01:00","description":"ServerManager: DocumentaciÃ³n TÃ©cnica Completa OrquestaciÃ³n Docker, TÃºneles Ngrok y AutomatizaciÃ³n vÃ­a Telegram ServerManager es una plataforma integral para la gestiÃ³n de infraestructura contenerizada. Permite administrar servidores SSH, FTP y Web a travÃ©s de un Dashboard moderno y un Bot de Telegram interactivo, integrando servicios de&hellip;","author":{"@type":"Person","name":"RubÃ©n GarcÃ­a","url":"https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/authors/ruben-garcia/"},"publisher":{"@type":"Organization","name":"RubÃ©n GarcÃ­a"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/">Desarrollo de interfaces</a></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Dashboard de servidores</h1><div class="feed__meta content__meta"><a href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/authors/ruben-garcia/" class="feed__author">RubÃ©n GarcÃ­a</a> <time datetime="2026-01-21T16:19" class="feed__date">January 21, 2026</time></div></div></header></div><div class="entry-wrapper content__entry"><header class="post-header align-center"><h1>ServerManager: DocumentaciÃ³n TÃ©cnica Completa</h1><div class="post-meta"><p>OrquestaciÃ³n Docker, TÃºneles Ngrok y AutomatizaciÃ³n vÃ­a Telegram</p></div></header><div class="post-content"><p class="align-center"><img src="https://img.shields.io/badge/Docker-2496ED?style=for-the-badge&amp;logo=docker&amp;logoColor=white" alt="Docker Badge" data-is-external-image="true"> <img loading="lazy" src="https://img.shields.io/badge/Node.js-339933?style=for-the-badge&amp;logo=nodedotjs&amp;logoColor=white" alt="Node.js Badge" data-is-external-image="true"> <img src="https://img.shields.io/badge/React-61DAFB?style=for-the-badge&amp;logo=react&amp;logoColor=black" alt="React Badge" data-is-external-image="true"> <img loading="lazy" src="https://img.shields.io/badge/Ngrok-1F1E38?style=for-the-badge&amp;logo=ngrok&amp;logoColor=white" alt="Ngrok Badge" data-is-external-image="true"></p><p class="lead"><strong>ServerManager</strong> es una plataforma integral para la gestiÃ³n de infraestructura contenerizada. Permite administrar servidores SSH, FTP y Web a travÃ©s de un Dashboard moderno y un Bot de Telegram interactivo, integrando servicios de exposiciÃ³n pÃºblica mediante Ngrok.</p><hr><nav class="toc-container"><h3>Ãndice de Contenidos</h3><ul><li><a href="#arquitectura">Arquitectura del Sistema</a></li><li><a href="#docker-core">Core: Control de Docker</a></li><li><a href="#ngrok-service">Acceso Remoto: Servicio Ngrok</a></li><li><a href="#ssh-ftp">Protocolos: SSH y FTP</a></li><li><a href="#telegram-bot">AutomatizaciÃ³n: Bot de Telegram</a></li><li><a href="#frontend">Dashboard &amp; Terminal Web</a></li><li><a href="#api">Referencia API</a></li></ul></nav><hr><section id="arquitectura"><h2>ğŸ—ï¸ Arquitectura del Sistema</h2><p>El sistema opera bajo un modelo de microservicios orquestados. El servidor API central gestiona la comunicaciÃ³n entre los clientes (Web/MÃ³vil) y los contenedores objetivo, utilizando tÃºneles seguros para exposiciÃ³n externa.</p><pre><code class="language-plaintext">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              CLIENTE                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Dashboard Web     â”‚              Bot Telegram                             â”‚
â”‚   (React + Vite)    â”‚         (node-telegram-bot-api)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                                      â”‚
          â–¼                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         SERVIDOR API (Node.js/Express)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Docker       â”‚  â”‚ SSH Client   â”‚  â”‚ FTP Service  â”‚  â”‚ Ngrok        â”‚    â”‚
â”‚  â”‚ Control      â”‚  â”‚              â”‚  â”‚              â”‚  â”‚ Service      â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        CONTENEDORES TARGET                                  â”‚
â”‚   SSH (2222)   |   FTP (2121)   |   Web (8080)                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre></section><hr><section id="docker-core"><h2>ğŸ³ Core: Control de Docker</h2><p>El servicio principal (<code>server/services/dockerControl.js</code>) interactÃºa directamente con el socket de Docker. A diferencia de un cliente estÃ¡ndar, este servicio implementa lÃ³gica de negocio especÃ­fica para filtrar y gestionar recursos en caliente.</p><h3>ModificaciÃ³n de Recursos en Tiempo Real</h3><p>El sistema convierte valores humanos (CPUs, MB) a las unidades internas del Kernel de Linux (NanoCpus, Bytes) para aplicar lÃ­mites sin reiniciar los contenedores.</p><pre><code class="language-javascript">const updateContainerResources = async (name, resources) =&gt; {
    const container = getContainer(name);
    const updateConfig = {};

    // ConversiÃ³n: 1 CPU = 1e9 NanoCpus
    if (resources.cpuLimit !== undefined) {
        updateConfig.NanoCpus = Math.floor(resources.cpuLimit * 1e9);
    }

    // ConversiÃ³n: MB a Bytes
    if (resources.memoryLimit !== undefined) {
        updateConfig.Memory = resources.memoryLimit * 1024 * 1024;
    }

    // AplicaciÃ³n inmediata mediante update API
    await container.update(updateConfig);
    return { success: true, name, updatedResources: resources };
};</code></pre><h3>FactorÃ­a de Contenedores</h3><p>La creaciÃ³n de servidores no es genÃ©rica; utiliza un mapa de imÃ¡genes predefinidas para asegurar que los contenedores creados sean compatibles con los servicios de gestiÃ³n del dashboard (SSH habilitado, usuarios configurados).</p><pre><code class="language-javascript">const createContainer = async (options) =&gt; {
    const { name, type } = options;
    
    // Mapa de imÃ¡genes base optimizadas
    const imageMap = {
        ssh: 'servermanager-ssh-target',
        ftp: 'servermanager-ftp-target',
        web: 'servermanager-web-target'
    };

    // ConfiguraciÃ³n automÃ¡tica de red y persistencia
    const containerConfig = {
        Image: imageMap[type],
        name: `${name}-${type}-target`,
        HostConfig: {
            RestartPolicy: { Name: 'unless-stopped' },
            NetworkMode: 'servermanager_default'
        }
    };
    // ... (lÃ³gica de creaciÃ³n e inicio)
};</code></pre></section><hr><section id="ngrok-service"><h2>ğŸŒ Acceso Remoto: Servicio Ngrok</h2><p>El servicio ubicado en <code>server/services/ngrokService.js</code> permite exponer servidores web locales a internet de forma segura. Gestiona el ciclo de vida de los tÃºneles y evita duplicados mediante un registro de tÃºneles activos.</p><h3>GestiÃ³n de TÃºneles</h3><p>El sistema verifica si ya existe un tÃºnel para el host:puerto solicitado antes de crear uno nuevo, optimizando el uso de conexiones y evitando errores de puerto.</p><pre><code class="language-javascript">const ngrok = require('@ngrok/ngrok');
let activeTunnels = {};

const startTunnel = async (targetHost, targetPort) =&gt; {
    const key = `${targetHost}:${targetPort}`;

    // 1. VerificaciÃ³n de cachÃ© de tÃºneles
    if (activeTunnels[key] &amp;&amp; activeTunnels[key].url) {
        return activeTunnels[key];
    }

    // 2. CreaciÃ³n del tÃºnel
    const listener = await ngrok.forward({
        addr: `${targetHost}:${targetPort}`,
        authtoken: process.env.NGROK_AUTHTOKEN,
        proto: 'http'
    });

    // 3. Registro del tÃºnel activo
    activeTunnels[key] = {
        url: listener.url(),
        listener: listener,
        createdAt: Date.now()
    };

    console.log(`ğŸŒ Ngrok tunnel: ${listener.url()} -&gt; ${key}`);
    return activeTunnels[key];
};</code></pre><h3>Limpieza de Recursos</h3><p>Es crÃ­tico cerrar los tÃºneles correctamente para no dejar procesos zombies. El servicio incluye una funciÃ³n para detener todos los tÃºneles simultÃ¡neamente.</p><pre><code class="language-javascript">const stopAllTunnels = async () =&gt; {
    for (const key of Object.keys(activeTunnels)) {
        if (activeTunnels[key].listener) {
            await activeTunnels[key].listener.close();
        }
    }
    activeTunnels = {};
};</code></pre></section><hr><section id="ssh-ftp"><h2>ğŸ’» Protocolos: SSH y FTP</h2><h3>Cliente SSH y Parsing de MÃ©tricas</h3><p>El servicio SSH (<code>sshClient.js</code>) no requiere agentes instalados en los servidores destino. Utiliza comandos estÃ¡ndar de Linux (<code>grep</code>, <code>awk</code>, <code>df</code>) para extraer mÃ©tricas vitales y parsearlas en JSON.</p><pre><code class="language-javascript">// Ejemplo: ObtenciÃ³n de uso de disco sin agentes
const diskcmd = "df -h / | awk 'NR==2 {print $5}' | sed 's/%//'";
const diskUsage = await executeCommand(host, port, user, pass, diskcmd);</code></pre><h3>GestiÃ³n Avanzada de FTP</h3><p>El servicio FTP (<code>ftpService.js</code>) maneja transferencias complejas. Para la ediciÃ³n de archivos, implementa un flujo de descarga temporal -&gt; lectura -&gt; ediciÃ³n -&gt; subida.</p><pre><code class="language-javascript">const downloadToPath = async (host, port, user, password, remotePath) =&gt; {
    // GeneraciÃ³n de ruta temporal segura en el contenedor API
    const localPath = `/tmp/ftp_download_${Date.now()}.bin`;
    await client.downloadTo(localPath, remotePath);
    return localPath;
};</code></pre></section><hr><section id="telegram-bot"><h2>ğŸ¤– AutomatizaciÃ³n: Bot de Telegram</h2><p>El bot (<code>server/services/telegramBot.js</code>) actÃºa como una segunda interfaz completa. Implementa un sistema de logs propio que se sincroniza con el dashboard web.</p><h3>VisualizaciÃ³n de Datos (ASCII Art)</h3><p>Para mostrar estadÃ­sticas de forma grÃ¡fica en una interfaz de texto, el bot renderiza barras de progreso usando caracteres Unicode.</p><pre><code class="language-javascript">const createProgressBar = (percentage) =&gt; {
    const filled = Math.round((percentage / 100) * 10);
    // Resultado visual: ğŸŸ¢ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘ 60%
    return 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(10 - filled);
};</code></pre><h3>Comandos e Interactividad</h3><p>El bot escucha patrones regex para ejecutar acciones complejas, como sesiones SSH remotas directamente desde el chat.</p><div class="chat-simulation" style="background: #1e293b; color: #e2e8f0; padding: 15px; border-radius: 8px; font-family: monospace; margin-bottom: 15px;"><p style="color: #60a5fa;"><strong>Usuario:</strong> /ssh 1 ls -la /var/www</p><p><strong>Bot:</strong> ğŸ”„ Ejecutando: `ls -la /var/www`...</p><hr style="border-color: #334155;"><p><strong>Bot:</strong><br>ğŸ’» <strong>Resultado SSH - #1</strong><br>ğŸ“¤ <strong>Salida:</strong><br>drwxr-xr-x 2 root root 4096 Jan 20 10:00 html<br>-rw-r--r-- 1 root root 612 Jan 19 15:30 index.nginx-debian.html</p></div><pre><code class="language-javascript">// Manejador de comando SSH
bot.onText(/\/ssh (\d+)\s+(.+)/, async (msg, match) =&gt; {
    const serverNum = parseInt(match[1]); // ID del servidor
    const command = match[2];             // Comando a ejecutar
    
    // EjecuciÃ³n y respuesta formateada en Markdown
    const output = await sshService.executeCommand(...);
    bot.sendMessage(chatId, `\`\`\`${output}\`\`\``, { parse_mode: 'Markdown' });
});</code></pre></section><hr><section id="frontend"><h2>ğŸ¨ Dashboard &amp; Terminal Web</h2><h3>Terminal SSH en Navegador</h3><p>La terminal (<code>Terminal.jsx</code>) utiliza <code>Socket.IO</code> para transmitir pulsaciones de teclas en tiempo real al backend, que las retransmite al servidor SSH, logrando una latencia mÃ­nima.</p><pre><code class="language-javascript">// Frontend: ConexiÃ³n WebSocket para terminal
socket.on('connect', () =&gt; {
    term.write(`\r\nConectando a ${serverName}...\r\n`);
    socket.emit('start-terminal', {
        host: serverName,
        port: 22,
        username: 'admin',
        password: 'password'
    });
});

// RecepciÃ³n de stream de datos del servidor
socket.on('data', (data) =&gt; {
    term.write(data); // Escribe directamente en xterm.js
});</code></pre><h3>Panel de Control del Bot</h3><p>El dashboard incluye un visor de logs en tiempo real (<code>TelegramBotPanel.jsx</code>) que permite a los administradores auditar las interacciones del bot y enviar mensajes proactivos.</p></section><hr><section id="api"><h2>ğŸŒ Referencia API</h2><p>Endpoints principales expuestos por el servidor Express.</p><div class="table-wrapper"><table><thead><tr><th>Contexto</th><th>MÃ©todo</th><th>Endpoint</th><th>DescripciÃ³n</th></tr></thead><tbody><tr><td><strong>Docker</strong></td><td>POST</td><td><code>/api/servers/:name/start</code></td><td>Inicia un contenedor detenido.</td></tr><tr><td><strong>Docker</strong></td><td>PUT</td><td><code>/api/servers/:name/resources</code></td><td>Actualiza CPU/RAM en caliente.</td></tr><tr><td><strong>Web</strong></td><td>POST</td><td><code>/api/web/deploy</code></td><td>Despliega archivos al servidor web.</td></tr><tr><td><strong>Telegram</strong></td><td>GET</td><td><code>/api/telegram/logs</code></td><td>Obtiene historial de chat del bot.</td></tr></tbody></table></div></section></div></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on January 21, 2026</p><div class="content__actions"><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"></div></div></div><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/authors/ruben-garcia/" rel="author">RubÃ©n GarcÃ­a</a></h3></div></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/novelavisual.html" class="content__nav-link" rel="prev"><div><span>Previous</span> NovelaVisual</div></a></div></div></div></nav></footer></article></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright">Powered by Publii</div><button id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://RubenGarcia11.github.io/DocumentacionDesarrolloInterfaces/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>